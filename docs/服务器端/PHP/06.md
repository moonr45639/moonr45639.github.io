<h6 align="right">山重水复疑无路，柳暗花明又一村。</h6>



## 什么是函数

<br>

​代码块

<br>

​便于进行复用

<br>

## 函数的内存分析

<br>

不会自动运行

<br>

函数运行是在栈中开辟内存

<br>

函数运行结束会自动释放占用的内存

<br>

PHP 脚本运行结束会释放所有内存

<br>

## 形参

<br>

### 默认值

<br>

定义形参时设定的预设值，没有传递实参时将会使用该值

<br>

## 实参

<br>

实参的数量要对应形参

<br>

少了会报错，多了会只取用前面的

<br>

## 参数的传值方式

<br>

### 值传递

<br>

内部运算，不影响外部

<br>

传值方式 ：常量、变量、表达式

### 引用传递

<br>

内部运算，同时影响外部

<br>

传值方式 ：变量

<br>

## 返回值

<br>

return 可以强制结束函数

<br>

## 函数规则

<br>

不区分大小写

<br>

见名思意

<br>

## 作用域

<br>

### 局部作用域

<br>

函数内部的作用域

<br>

局部变量只能在函数内部被访问

<br>

形参同理

<br>

### 全局作用域

<br>

未在其他结构内部定义的作用域

<br>

全局变量不能直接在局部作用域内访问

<br>

全局变量可以作为实参使用

<br>

### 超全局作用域

<br>

系统定义的预定义变量

<br>

不受作用域限制，脚本任意位置都可以访问

<br>

可以利用超全局变量来保存数据，使数据不受作用域限制（ 一般只用来访问数据 ）

<br>

### 跨作用域访问

<br>

在局部作用域访问全局变量，或在全局作用域访问局部变量

<br>

## global

<br>

在函数内部使用 global 关键字声明变量（ 只能声明，不能赋值 ）

<br>

在函数内部生成一个局部变量（ 如果同名的全局变量原本就存在，将直接在函数内引用该全局变量 ）

<br>

同时在函数外部生成一个同名的全局变量

<br>

两个变量指向相同的内存地址

<br>

函数运行结束时，内部的局部变量消失；外部的全局变量仍然存在

<br>

## 静态变量

<br>

在函数内部定义的使用 static 关键字定义的局部变量

<br>

static 修饰的变量在函数编译时初始化

<br>

在函数调用时会跳过执行

<br>

静态变量保存在函数中，每次调用时修改的值在下次调用时会被使用

<br>

静态变量可以让函数在多次调用时共享内部数据变化

<br>

（ 可以在函数使用递归储存数据时使用 ）

<br>

## 强类型

<br>

### 强类型参数

<br>

在定义函数时给形参设定好对应的数据类型

<br>

实参必须时形参规定的函数类型，可以保护函数内部的运行逻辑正确

<br>

PHP 是弱类型语言，会自动转换类型，一般可以不用

<br>

不想在函数内部进行过多逻辑判断时可以使用

<br>

~~~php
function add(int $a, int $b){
    echo $a + $b;
}
~~~

<br>

### 强类型返回值

<br>

强类型返回值是指在定义函数时规定返回值类型

<br>

在函数内部使用返回值时必须对应返回值类型

<br>

想让强类型返回值生效，必须开启严格类型

<br>

强类型返回值可以保证数据的规范性（ 对外提供规范的数据 ）

<br>

~~~php
declare(strict_types = 1);  // 开启强类型检查

function is_my_int($n): bool{
    if(is_integer($n)){
        return true;
    } else{
        return false;
    }
}
~~~

<br>

## 可变参数

<br>

PHP 提供了一种对参数不固定的处理方式

<br>

一种主动获取多余实参的方式

<br>

形参中可以定义可变参数，吸收多余的实参变成数组

<br>

~~~php
function num($a, $b, ...$more){
    $sum = $a + $b;
    foreach($more as $value){
        $sum += $value;
    }
    
    return $sum;
}
~~~

<br>

实参传递数据时可以利用可变参数将数据解构成多个参数

<br>

~~~php
function num($a, $b){
    return $a - $b;
}

echo num(...[2, 1]);	// 当数组内数据比形参个数多时只会采用前面的几个
~~~

<br>

## 可变函数

<br>

当一个变量保存的数据是一个函数的名字时，可以通过变量调用函数

<br>

~~~php
function hi(){
    echo 'hello world';
}

$a = 'hi';
echo $a();	// hello world
~~~

<br>

可以利用可变函数将某个函数作为另一个函数的回调函数使用

<br>

~~~php
function hi(){
    return 'hello world';
}

function w($m, $fuction){
    echo $m . $fuction();
}
w('me','hi');
~~~

<br>

## 匿名函数

<br>

将没有名字的函数保存在变量中

<br>

本质是给函数赋值，所以要加分号

<br>

通过变量来调用匿名函数

<br>

### 回调匿名函数

<br>

直接将匿名函数定义在函数的实参中传递给形参

<br>

回调匿名函数阅后即焚，可以释放占用的内存

<br>

~~~php
function add($arr, $do){
    $sum = 0;
    foreach($arr as $value){
        $sum += $do($value);
    }
    
    return $sum;
}

echo add(
    [1, 1, 2], function ($n){
    return $n ** 2;
}
);
~~~

<br>

### 匿名函数闭包

<br>

一个定义在函数内，能够读取其他函数内部变量的函数

<br>

~~~php
function out(){		// 一个简单的闭包函数
    $inner = function(){
        echo 'hello world';
    };
    $inner();
}
out();	// hello world
~~~

<br>

虽然闭包函数在函数内部，但是它无法直接使用外部函数的局部变量

<br>

可以使用 use 来引用外部函数的局部变量

<br>

~~~php
function out($str){
    $inner = function ()use ($str){
      echo $str;
    };
    $inner();
}
out('hi');
~~~

<br>

闭包函数可以作为外部函数的返回值返回，这样闭包所占用的外部资源不会被释放

<br>

~~~php
function out($str){
    $inner = function ($s)use ($str){
        echo $str . $s;
    };
    
    return $inner;
}
~~~

<br>

## 命名空间

<br>

可以通过命名空间来隔离不同文件中的同名函数

<br>

使用命名空间后调用函数时要在前面加上空间的名字

<br>

